<!-- TOC -->

- [安装](#安装)
- [复制](#复制)
- [Sentinel 哨兵](#sentinel-哨兵)
- [集群](#集群)
    - [重新分片](#重新分片)
    - [故障转移](#故障转移)

<!-- /TOC -->

# 安装
* 配置文件路径: `/usr/local/etc/redis.conf`


# 复制

同步复制：
* 从服务器向主服务器发送 `SYNC` 命令。
* 主服务器执行 `BGSAVE` 命令，在后台生成 RDB 文件，并用缓冲区记录从现在开始的所有写命令。
* 主服务器把 RDB 文件发给从服务器，从服务器载入它。
* 主服务器把缓冲区的所有写命令发给从服务器，从服务器执行它。

初次复制时上面的步骤没有问题，但是如果从服务器断线后重新连接了，再执行上面的步骤就浪费性能了。

`PSYNC` 命令具有完整重同步和部分重同步模式：
* 完整重同步和 `SYNC` 相同，用于初次复制的情况。
* 部分重同步只会将断线的这段时间内的写命令同步给从服务器。

部分重同步：
* 主服务器内有一个写命令的缓冲区（默认 1M），记录了每个字节的偏移量。
* 从服务器发送 `PSYNC` 命令时会带上自己的复制偏移量。
* 如果偏移量在缓冲区内，那么就从偏移量后面开始同步。
* 如果偏移量不在缓冲区内，就执行完整重同步。
* 另外，从服务器重新上线后会带上断线前的主服务器的运行 ID(随机值)，如果 ID 和现在的主服务器不同，还是会执行完整重同步。

心跳检测：
* 从服务器每秒向主服务器发送 `REPLCONF ACK <replication_offset>` 命令。



# Sentinel 哨兵

Sentinel 是 Redis 的高可用解决方案，Sentinel 系统会监控主服务器和从服务器，当主服务器下线后从 从服务器 中选出一个作为新的主服务器，原来的主服务器在上线后会变为从服务器。

Sentinel 系统由一台或多台机器组成。

启动过程：
* Sentinel 机器在启动时会连接主服务器，一共两条连接：命令连接（发送命令）和订阅 `__sentinel__:hello` 频道的连接。
* Sentinel 向主服务器定期发送 `INFO` 命令获取主服务器和从服务器的信息。
* Sentinel 向从服务器定期发送 `INFO` 命令获取从服务器的信息。
* Sentinel 定期向主服务器和从服务器的 `__sentinel__:hello` 频道发送 Sentinel 和主服务器的信息，其他 sentinel 就能从该频道获知这个 sentinel 和主服务器的信息。
* 创建到其他 sentinel 的连接，只有一个连接，不创建订阅连接。

主服务器下线的判断：
* 定期向主服务器、从服务器、其他 sentinel 发送 `PING` 命令，根据回复来判断是否在线。
* sentinel 的配置中有一个 `down_after_milliseconds` 的配置，如果在这个时间段内没有收到有效回复就认为 **主观下线** 了。（不同 sentinel 的配置可能不同）
* 向其他 sentinel 询问该机器是否下线，如果超过一定数量(配置中的 quorum)的 sentinel 认为下线了，那么就判断为 **客观下线** 了。

选举领头 sentinel（类似 raft 协议）:
* 配置纪元増一。
* 在纪元内，发现主服务器客观下线的 sentinel 会要求其他 sentinel 选举自己。
* 其他 sentinel 选举的规则是先到先得且只选一个。
* 超过半数投票则选举成功，否则一段时间后再选举。

故障转移操作：
* 领头 sentinel 在已下线主服务器的从服务器中选出一个作为新的主服务器。
* 其他从服务器从新的主服务器复制数据。
* 在已下线主服务器上线后让其成为从服务器。

在从服务器中选择主服务器：
* 必须是在线的。
* 去掉 5 秒内没有回复 `INFO` 命令的。
* 去掉和主服务器断开连接超过一定时间的从服务器。
* 选择复制偏移量最新的。
* 选择运行 ID 最小的。


# 集群

* 通过向节点发送 `CLUSTER MEET` 信息将另一个节点加入到本节点的集群中。它们之间会相互握手以便建立连接。
* 每个节点都保存集群内其他节点的信息。
* 通过命令指定每个节点负责处理哪些槽，将 16384(2k*8) 个槽分给各个节点来处理。只有所有的槽都有节点在处理时集群才处于上线状态。每个节点会将自己负责的槽信息传播给其他节点，这样每个节点都掌握槽应该由哪个节点来处理。
* 当客户端向集群中的节点发送命令时，节点会计算要处理的键处于哪个槽中，如果需要自己处理那就执行命令，如果需要其他节点来处理，就向客户端发送 `MOVED` 错误，让客户端重试正确的节点。


计算键属于哪个槽： `CRC16(key) & 16383`。

节点中会使用跳跃表来记录每个槽中有哪些键，按照槽来排序。

## 重新分片

将原本属于某个节点的键分配给其他节点, 由 Redis 的集群管理软件 redis-trib 负责执行。

重新分片可以在线进行，集群不需要下线。

redis-trib 对 **单个槽** 进行重新分片的步骤：
* redis-trib 向目标节点发送命令让其准备好导入属于槽 slot 的键值对。
* redis-trib 向源节点发送命令让其准备好将键值对迁移到目标节点。
* redis-trib 从源节点获取 count 个键的名称。对于每个键，都发送一次命令让源节点将其原子地迁移到目标节点。重复这个步骤，直到属于该槽的所有键值对都被迁移到目标节点。
* redis-trib 向机器中任一节点发送命令，将槽 slot 指派给目标节点，这个信息会通过消息发送至整个集群。

ASK 错误： 如果属于某个槽的键值对一部分在源节点，一部分在目标节点。如果这时客户端需要处理某个正在被迁移的键，源节点会先在自己的库里查找有没有这个节点，如果有就执行命令，如果没有就返回一个 ASK 错误，让客户端到目标节点去执行命令。


## 故障转移

* 集群的节点之间会互相通信，当半数以上主节点认为某个节点处于下线状态（一段时间内未响应），那么就向集群广播一条节点下线的消息。
* 该节点的从节点会负责故障转移，从所有从节点中选择一个节点（类似 raft 的选举），该从节点会成为主节点，并撤销原主节点的槽指派，将槽指向自己。
* 新的主节点向集群发送消息，宣布自己成为主节点并负责原来的槽。

