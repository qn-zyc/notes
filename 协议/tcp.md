<!-- TOC -->

- [经受时延的确认](#经受时延的确认)
- [Nagle 算法](#nagle-算法)
- [滑动窗口](#滑动窗口)
- [慢启动](#慢启动)
- [超时与重传](#超时与重传)
- [坚持定时器](#坚持定时器)
- [保活定时器](#保活定时器)
- [TCP粘包分析](#tcp粘包分析)
    - [什么时候需要考虑粘包问题](#什么时候需要考虑粘包问题)
    - [粘包的原因](#粘包的原因)
    - [解决方法](#解决方法)

<!-- /TOC -->


# 经受时延的确认

TCP 在收到数据时并不立刻发送 ACK，而是将 ACK 与需要沿该方向发送的数据一起发送。

如果时延为 200ms，那么在 200ms 内如果有数据需要发送，那么 ACK 和数据一起发送，如果没有数据需要发送，那么 200ms 后 ACK 单独发送出去。


# Nagle 算法

定义： TCP 连接上最多只能有一个未被确认的小段，小段是指小于 MSS(Maximum Segment Size最大报文段长度) 尺寸的数据块，未被确认是指没有收到 ACK。

用途： 小包太多会造成网络利用率低，Nagle 算法是为了避免发送大量的小包的。

做法： 发送端想要多次发送小包，先将第一个小包发送出去，剩下的缓存起来，直到收到第一个包的 ACK 或者以下情况时才会将剩下的包组成一个较大的包发送出去，这些情况包括：
1. 如果包长度达到MSS，则允许发送；
2. 如果该包含有FIN，则允许发送；
3. 设置了TCP_NODELAY选项，则允许发送；
4. 未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；
5. 上述条件都未满足，但发生了超时（一般为200ms），则立即发送。

当遇上延时确认机制时， ACK 会延时发送，此时会导致明显的延时。还有交互性要求比较高的应用可能会禁用 Nagle 算法以避免延时。


# 滑动窗口

左边是已经发送出去但还没收到 ACK 的报文段，右边是还没发送出去的。窗口大小是根据接收方定义的？

ACK 累积： 当收到多个报文时，ACK 报文并不是产生多个，而是可能一个 ACK 就确认了所有的报文。


# 慢启动

拥塞窗口(congestion window, cwnd): 初始化时只有一个报文段，当收到 ACK 时增加为 2 个报文段, 每收到一个 ACK 就增加一个报文额度，这样总体是呈指数级增加的。发送方取拥塞窗口和滑动窗口的最小值作为发送上限。

拥塞避免算法： 初始时 cwnd(拥塞窗口) 为一个报文段， ssthresh(慢启动门限) 为 65535 个字节。 当拥塞发生时（遇到超时或收到重复确认）， ssthresh 设置为 min(cwnd/2, 接收方通告窗口大小, 2)， 如果是超时引起的拥塞， cwnd 设置为1（慢启动）。 TODO: 后面的有点复杂。

拥塞窗口是发送方使用的流量控制，而滑动窗口是接收方使用的流量控制。


# 超时与重传

4 个定时器：
1. 重传定时器： 用于接收另一端的确认。
2. 坚持定时器： 窗口大小信息保持流动。
3. 保活定时器： 检测空闲连接的另一端何时崩溃或重启。
4. 2MSL 定时器： 测量一个连接处于 `TIME_WAIT` 状态的时间。


重传时不一定要重传同样的报文段，可以重新分组发送一个较大的报文段。因为 **TCP 是使用字节序号而不是报文段序号来识别要发送的数据和进行确认**。


# 坚持定时器

TCP 收到 ACK 报文时不会对这个报文发送确认报文，这可能造成这种情况：窗口大小为0，而接收端发送的 ACK 丢失了，这样的话发送端和接收端都处于等待的状态，造成死循环。

坚持定时器会定期发送一个字节的报文，收到 ACK 后就能重新设置窗口大小了。



# 保活定时器

TCP 连接上可以不发送任何数据，这样当另一端挂掉或中间的路由器挂掉后就探测不到连接是否存活了。

保活定时器会定期发送探查报文段以探测连接是否存活。




# TCP粘包分析

* [原文](http://blog.csdn.net/zhangxinrun/article/details/6721495)

## 什么时候需要考虑粘包问题

* 每次都建立连接,发送完数据后就断开连接,这时不会发生粘包问题. 因为只有一段数据, 没法和其他数据粘连.
* 发送的数据无结构, 比如文件传输, 也不需要考虑粘包问题.
* 发送的数据没有边界时,需要考虑.
* UDP 不需要考虑粘包, 因为它是有界限的. 而 TCP 是基于流的, 没有包的概念, 所以才会出现粘包问题.

## 粘包的原因

* 发送端需要等缓冲区满了才发送.
* 接收端没有及时接收缓冲区的包.

## 解决方法

* 在报文末尾添加换行符。
* 消息分为消息头和消息体，消息头中声明消息的长度。
* 固定报文长度，不足的空位补齐。
